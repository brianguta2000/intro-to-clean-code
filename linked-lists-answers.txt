1. What are some pros and cons of using linked lists instead of arrays?

Pros are they don't use up valuable memory, can be large in size but they can be slow to access what you're looking for.

2. Come up with a real world example of a linked list.

A: A phone tree. While somewhat outdated, in order to access everyone in a phone tree, one must start by calling the number you know and getting the number of the next person in the tree. Granted, the phone tree is usually used to deciminate information rather than collect it.

Programming Questions

1. The linked list push function should take a value, create a node, and add it to the end of a list. Below is pseudocode for a push function for a singly linked list. However, there is something wrong with it. Submit both an explanation of the bug and a functional implementation of the method.

A: This function will not add the node to the end of the list. 
Instead it will reorganize the data and always add the new node right behind the head node instead of traversing it.


FUNCTION push(element)
CREATE node
SET node.value TO element
SET node.next TO null

IF the head node does not exist
 THEN SET head to node
ELSE
 SET current to head
 SET current.next to node
END IF
END FUNCTION

push(element) {
    var node = new Node(element);
    var current;

    if (this.head == null) {
      this.head = node;
    } else {
      current = this.head;

      while (current.next) {
        current = current.next;
      }
      
      current.next = node;
    }
    
    console.log(LinkedList)
  }

2. Given an unsorted singly linked list, remove all duplicates from the linked list.


class LinkedList {
	constructor() {
		this.head = null;
	}
}

class Node {
	constructor(val) {
		this.value = val;
		this.next = null;
	}
}

function removeDuplicates(list){
  var node = list.head;
  var sort = [];
  array.push(list.head.value);
 
  while(node.next){
    if(sort.indexOf(node.next.value) != -1){
       node.next = node.next.next;
     } 
     else {
       sort.push(node.next.value);
       node = node.next;
     }
  }
  
  return list;
};

var list = new LinkedList();
var firstNode = new Node('a');
var secondNode = new Node('c');
var thirdNode = new Node('d');
var fourthNode = new Node('d');
var fifthNode = new Node('a');

list.head = firstNode;
firstNode.next = secondNode;
secondNode.next = thirdNode;
thirdNode.next = fourthNode;
fourthNode.next = fifthNode;

removeDuplicates(list);
	
}


3. Given an unsorted singly linked list, reverse it.
Example
Input: a -> b -> c -> d
Output: d -> c -> b -> a


class LinkedList {
	constructor() {
		this.head = null;
	}
}

class Node {
	constructor(val) {
		this.value = val;
		this.next = null;
	}
}

function reverseList(list) {
	var current = list.head;
	var prev = null;

	while(current) {
		next = current.next;
		current.next = prev;
		prev = current;
		current = next;
	}
	return prev;
}

var list = new LinkedList();
var node1 = new Node('a');
var node2 = new Node('b');
var node3 = new Node('c');
var node4 = new Node('d');

list.head = node1;
node1.next = node2;
node2.next = node3;
node3.next = node4;
