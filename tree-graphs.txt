1. A binary tree is a data structure that each node can have at most 2 child nodes (left and right).

2. Heuristics are guesses that an algorithm makes to solve a complex problem sooner by sacrificing accuracy.

3. Another problem that requires the use of heuristics is playing a chess game, since there are numerous different moves the opponent can make, the algorithm can only make guesses on the most possible moves that would lead to a victory.

4. DFS traverse from the root to as far as possible along each branch before backtracking. BFS traverse from the root to the next level neighbors layer by layer until the most bottom layer.

5. Undirected, a-cyclic, unweighted graph is that each node of the graph can go to any other node without forming a loop and there's no assigned weight for any edges on the graph.

6. A binary search tree is an directed, a-cyclic, unweighted graph.

Programming Questions

1. To find if a number exists in a binary search tree, start from the head node, if the the number is bigger than the node value, go to the right. Otherwise, go left. Repeatedly comparing the same way until the number is found or the bottom of the tree is reached. If can't go any further, the number does not exist in the tree.

class Node {
	constructor(val) {
		this.value = val;
		this.left = null;
		this.right = null;
	}
}

function binaryTree(){
	this.root = null;
	
	this.push = function(val) {
		var root = this.root;
		if(!root) {
			this.root = new Node(val);
			console.log("New Root")
			return;
		}

	var currentNode = root;
	var newNode = newNode(val);
	while(currentNode) {
		if (val < currentNode.value) {
			if(!currentNode.left) {
				currentNode.left = newNode;
				break;
			} else {
				currentNode = currentNode.left;
			}
				
		}else {
			if (!currentNode.right) {
					currentNode.right = newNode;
					break;
				}
				else {
					currentNode = currentNode.right;
				}
			}
		}
	}	

	this.contains = function(val) {
		var root = this.root;
		var currentNode = root;
		var foundValue = false;
		while(!foundValue && currentNode) {
			if(val < currentNode.val) {
				currentNode = currentNode.left;
			}
			else if (val > currentNode.val) {
				currentNode = currentNode.right;
			}
			else {
				foundValue = true;
			}
		}
		return foundValue;	
	}
};
var bst = new BinaryTree();
bst.push(3);
bst.push(2);
bst.push(4);
bst.push(1);
bst.push(5);
console.log(bst)
bst.findVal(7);

2. To find the distance, the first thing is to look for the root node which is equal or smaller than n1, and equal or bigger than n2. Then add up the distance from root to n1 and root to n2.

function findDistance(root, n1, n2){
  if (root === null || n1 === n2){
    return 0;
  }
  distance.left = findDistance(root.left, n1, n2);
  distance.right = findDistance(root.right, n1, n2);

  if (distance.left > 0 && distance.right > 0){
    return distance.left + distance.right;
  }
  if (distance.left > 0 && distance.right > 0){
    return distance.left;
  }
  if (distance.right > 0 && root === n1 || n2){
    return distance.right;
  }
  if (distance.left === 0 && distance.right === 0){
    if(root !== n1 || n2){
      return 0;
    }
    if (root == n1 || n2){
      return 1;
    }
    } else {
      return max(distance.left, distance.right) + 1;
    }